# Requirements Document

## Introduction

This document specifies the requirements for ShadowLend's Solana Smart Contracts, which form the on-chain foundation of the privacy-preserving lending protocol. The contracts manage lending pools, user obligations (encrypted state), and integrate with Arcium's MXE network for confidential computation. The system enables users to deposit collateral, borrow assets, and participate in liquidations while keeping individual positions private.

## Glossary

- **Pool**: A Solana account storing public protocol state including total deposits, borrows, interest rates, and utilization metrics
- **UserObligation**: A Solana account storing a user's encrypted financial state (deposits, borrows, collateral) as an opaque blob
- **MXE**: Multi-Party eXecution Environment - Arcium's confidential compute network that processes encrypted data
- **Attestation**: A cryptographic proof generated by MXE nodes certifying correct computation
- **Health_Factor**: A ratio indicating position safety; values below 1.0 trigger liquidation eligibility
- **LTV**: Loan-to-Value ratio - the percentage of collateral value that can be borrowed
- **Encrypted_State_Blob**: AES-256-GCM encrypted user balance data stored on-chain, decryptable only by MXE nodes
- **State_Commitment**: SHA-256 hash of encrypted state blob for integrity verification
- **Arcium_Config**: Registry of trusted MXE nodes and their attestation parameters
- **CPI**: Cross-Program Invocation - Solana mechanism for programs to call other programs

## Requirements

### Requirement 1: Pool Initialization

**User Story:** As a protocol administrator, I want to initialize lending pools, so that users can deposit and borrow specific token types.

#### Acceptance Criteria

1. WHEN an administrator calls the initialize_pool instruction with valid parameters, THE Pool_Program SHALL create a new Pool account with the specified mint, authority, and risk parameters
2. THE Pool_Program SHALL set initial values: total_deposits=0, total_borrows=0, accumulated_interest=0, utilization_rate=0
3. WHEN initializing a pool, THE Pool_Program SHALL store the liquidation_threshold (default 80% LTV) and reference to Arcium_Config
4. IF a pool already exists for the given mint, THEN THE Pool_Program SHALL reject the initialization and return an error

### Requirement 2: Pool State Management

**User Story:** As a protocol, I want to maintain accurate pool state, so that interest rates and utilization can be calculated correctly.

#### Acceptance Criteria

1. THE Pool_Program SHALL store and expose public aggregates: total_deposits, total_borrows, utilization_rate, current_borrow_rate, current_deposit_rate
2. WHEN total_deposits or total_borrows change, THE Pool_Program SHALL recalculate utilization_rate as (total_borrows / total_deposits) * 100000
3. WHEN utilization_rate changes, THE Pool_Program SHALL update current_borrow_rate and current_deposit_rate using the interest rate model
4. THE Pool_Program SHALL update last_update_ts timestamp on every state modification

### Requirement 3: User Obligation Account Creation

**User Story:** As a user, I want to have a dedicated obligation account, so that my encrypted position data can be stored on-chain.

#### Acceptance Criteria

1. WHEN a user first interacts with a pool (deposit or borrow), THE Pool_Program SHALL create a UserObligation account if one does not exist
2. THE UserObligation account SHALL store: user pubkey, pool reference, encrypted_state_blob, state_commitment, last_mxe_attestation, and last_update_ts
3. THE Pool_Program SHALL derive UserObligation PDA from user pubkey and pool pubkey for deterministic addressing
4. IF a UserObligation already exists for the user-pool pair, THEN THE Pool_Program SHALL use the existing account

### Requirement 4: Deposit Instruction

**User Story:** As a user, I want to deposit collateral into a lending pool, so that I can earn interest and use it as collateral for borrowing.

#### Acceptance Criteria

1. WHEN a user calls the deposit instruction with encrypted_data and amount, THE Pool_Program SHALL verify the user has sufficient token balance
2. THE Pool_Program SHALL transfer tokens from user's token account to the pool's token vault
3. THE Pool_Program SHALL forward the encrypted_data to Arcium MXE via CPI for state update
4. WHEN MXE returns an attestation and encrypted_state_blob, THE Pool_Program SHALL verify the attestation and update the UserObligation account
5. THE Pool_Program SHALL increment pool.total_deposits by the deposit amount
6. IF attestation verification fails, THEN THE Pool_Program SHALL revert the entire transaction

### Requirement 5: Borrow Instruction

**User Story:** As a user, I want to borrow assets against my collateral, so that I can access liquidity without selling my holdings.

#### Acceptance Criteria

1. WHEN a user calls the borrow instruction with encrypted_request, THE Pool_Program SHALL verify the pool has sufficient liquidity
2. THE Pool_Program SHALL forward the encrypted_request to Arcium MXE via CPI for health factor validation
3. WHEN MXE returns approval attestation, THE Pool_Program SHALL transfer borrowed tokens from pool vault to user's token account
4. THE Pool_Program SHALL update UserObligation with new encrypted_state_blob from MXE
5. THE Pool_Program SHALL increment pool.total_borrows by the borrow amount
6. IF MXE returns rejection (insufficient collateral), THEN THE Pool_Program SHALL reject the borrow and emit an error event

### Requirement 6: Repay Instruction

**User Story:** As a user, I want to repay my borrowed assets, so that I can reduce my debt and improve my health factor.

#### Acceptance Criteria

1. WHEN a user calls the repay instruction with amount and encrypted_data, THE Pool_Program SHALL transfer tokens from user to pool vault
2. THE Pool_Program SHALL forward repayment data to Arcium MXE via CPI for state update
3. WHEN MXE returns attestation with updated state, THE Pool_Program SHALL update UserObligation account
4. THE Pool_Program SHALL decrement pool.total_borrows by the repay amount
5. IF repay amount exceeds user's debt (determined by MXE), THEN THE Pool_Program SHALL repay only the outstanding debt and return excess

### Requirement 7: Withdraw Instruction

**User Story:** As a user, I want to withdraw my deposited collateral, so that I can access my funds when needed.

#### Acceptance Criteria

1. WHEN a user calls the withdraw instruction with encrypted_request, THE Pool_Program SHALL forward to MXE for health factor validation
2. WHEN MXE approves withdrawal (health factor remains >= 1.0 after withdrawal), THE Pool_Program SHALL transfer tokens from pool vault to user
3. THE Pool_Program SHALL update UserObligation with new encrypted_state_blob
4. THE Pool_Program SHALL decrement pool.total_deposits by the withdrawal amount
5. IF MXE rejects withdrawal (would cause health factor < 1.0), THEN THE Pool_Program SHALL reject and emit an error event

### Requirement 8: Liquidation Instruction

**User Story:** As a liquidator, I want to liquidate undercollateralized positions, so that I can earn liquidation bonuses while maintaining protocol solvency.

#### Acceptance Criteria

1. WHEN a liquidator calls the liquidate instruction with target user and encrypted_request, THE Pool_Program SHALL forward to MXE for health factor check
2. WHEN MXE confirms health_factor < 1.0 and returns liquidation parameters, THE Pool_Program SHALL execute the liquidation atomically
3. THE Pool_Program SHALL transfer repay_amount tokens from liquidator to pool vault
4. THE Pool_Program SHALL transfer collateral_to_seize tokens from pool vault to liquidator (including 5% liquidation bonus)
5. THE Pool_Program SHALL update target user's UserObligation with new encrypted_state_blob
6. THE Pool_Program SHALL emit a LiquidationExecuted event with public liquidation amounts
7. IF MXE determines position is not liquidatable (health_factor >= 1.0), THEN THE Pool_Program SHALL reject the liquidation

### Requirement 9: Attestation Verification

**User Story:** As a protocol, I want to verify MXE attestations, so that only correctly computed results are accepted on-chain.

#### Acceptance Criteria

1. WHEN receiving an attestation from MXE, THE Pool_Program SHALL verify the MXE node pubkey is registered in Arcium_Config
2. THE Pool_Program SHALL verify the attestation signature using Ed25519 against the registered attestation_key
3. THE Pool_Program SHALL verify the MRENCLAVE measurement matches the trusted enclave measurement in Arcium_Config
4. THE Pool_Program SHALL verify the attestation timestamp is within 60 seconds of current time
5. THE Pool_Program SHALL verify the state_commitment matches the hash of the encrypted_state_blob
6. IF any verification step fails, THEN THE Pool_Program SHALL reject the attestation and revert the transaction

### Requirement 10: Arcium Configuration Management

**User Story:** As a protocol administrator, I want to manage trusted MXE nodes, so that only authorized nodes can provide attestations.

#### Acceptance Criteria

1. WHEN an administrator calls initialize_arcium_config, THE Pool_Program SHALL create an Arcium_Config account with the authority pubkey
2. THE Pool_Program SHALL allow the authority to add MXE nodes with: node_pubkey, attestation_key, enclave_measurement, is_active flag
3. THE Pool_Program SHALL allow the authority to deactivate MXE nodes by setting is_active to false
4. THE Pool_Program SHALL only accept attestations from nodes where is_active is true
5. IF a non-authority attempts to modify Arcium_Config, THEN THE Pool_Program SHALL reject the transaction

### Requirement 11: Interest Rate Model

**User Story:** As a protocol, I want to calculate interest rates based on utilization, so that rates adjust dynamically to market conditions.

#### Acceptance Criteria

1. THE Pool_Program SHALL implement a linear utilization-based interest rate model
2. WHEN utilization is below optimal (80%), THE Pool_Program SHALL calculate borrow_rate = base_rate + (utilization * slope1)
3. WHEN utilization is at or above optimal (80%), THE Pool_Program SHALL calculate borrow_rate = base_rate + (optimal * slope1) + ((utilization - optimal) * slope2)
4. THE Pool_Program SHALL calculate deposit_rate = borrow_rate * utilization * (1 - reserve_factor)
5. THE Pool_Program SHALL store rates in basis points (1 basis point = 0.01%)

### Requirement 12: Update Obligation from MXE

**User Story:** As a protocol, I want to accept state updates from MXE, so that user positions can be updated after confidential computation.

#### Acceptance Criteria

1. WHEN MXE completes computation and returns results, THE Pool_Program SHALL accept the update_obligation instruction
2. THE Pool_Program SHALL verify the attestation before accepting any state changes
3. THE Pool_Program SHALL update UserObligation.encrypted_state_blob with the new encrypted data
4. THE Pool_Program SHALL update UserObligation.state_commitment with the new commitment hash
5. THE Pool_Program SHALL update UserObligation.last_mxe_attestation with the attestation data
6. THE Pool_Program SHALL update UserObligation.last_update_ts with current timestamp

### Requirement 13: Error Handling

**User Story:** As a user, I want clear error messages, so that I understand why transactions fail.

#### Acceptance Criteria

1. IF pool has insufficient liquidity for borrow, THEN THE Pool_Program SHALL return InsufficientPoolLiquidity error
2. IF user has insufficient balance for deposit or repay, THEN THE Pool_Program SHALL return InsufficientUserBalance error
3. IF attestation verification fails, THEN THE Pool_Program SHALL return InvalidAttestation error with specific reason
4. IF MXE node is not registered or inactive, THEN THE Pool_Program SHALL return InvalidMxeNode error
5. IF attestation is older than 60 seconds, THEN THE Pool_Program SHALL return AttestationTooOld error
6. IF unauthorized user attempts admin action, THEN THE Pool_Program SHALL return Unauthorized error

### Requirement 14: Event Emission

**User Story:** As an external observer, I want to monitor protocol activity through events, so that I can track deposits, borrows, and liquidations.

#### Acceptance Criteria

1. WHEN a deposit completes successfully, THE Pool_Program SHALL emit a DepositCompleted event with pool, user, and amount
2. WHEN a borrow completes successfully, THE Pool_Program SHALL emit a BorrowCompleted event with pool, user, and amount
3. WHEN a repayment completes successfully, THE Pool_Program SHALL emit a RepayCompleted event with pool, user, and amount
4. WHEN a withdrawal completes successfully, THE Pool_Program SHALL emit a WithdrawCompleted event with pool, user, and amount
5. WHEN a liquidation executes, THE Pool_Program SHALL emit a LiquidationExecuted event with pool, liquidator, target_user, repay_amount, and collateral_seized
